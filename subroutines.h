#ifndef SUBROUTINES_H
#define SUBROUTINES_H

#include "simulationcell.h"

using namespace std;





/****************************************************************************************************
* Get the effective field generated by neighbouring spins (up to J constant)
 ****************************************************************************************************/
int GetEffectiveField(SimulationCell& SC, int ispin){
    int field = 0; 
    for (auto jspin =SC.GetLattice().at(ispin).begin(); 
              jspin!=SC.GetLattice().at(ispin).end(); 
              jspin++)
        field += SC.GetSpins().Get(*jspin);
     
    return field;  
}

/****************************************************************************************************
* Get the total energy (up to J constant)
 ****************************************************************************************************/
int GetEnergy(SimulationCell& SC){
    int energy = 0; 

    int istate = 0;
    for (int ispin=0; ispin!=SC.GetSize(); ispin++){
        istate = SC.GetSpins().Get(ispin);
        for (auto jspin =SC.GetLattice().at(ispin).begin(); 
                  jspin!=SC.GetLattice().at(ispin).end(); 
                  jspin++)
            energy += istate*SC.GetSpins().Get(*jspin);
    } 
    return (int) energy/2; // divide by 2 to compensate for the double counting  
}

/****************************************************************************************************
* Get the total boundary energy (up to J constant)
 ****************************************************************************************************/
int GetBoundaryEnergy(SimulationCell& SC){
    int E = 0;
    for (auto bp =SC.GetBoundary().begin(); 
              bp!=SC.GetBoundary().end(); 
              bp++)
        E += SC.GetSpins().Get(bp->first) * SC.GetSpins().Get(bp->second);

    return E;
}
#endif
